// SmallSteps Claude Adapter
// Implements AIProvider interface using server-side API route

import type { AIProvider, GoalPlan, TaskPlan, EffortEstimate } from './ai-provider';

export class ClaudeAdapter implements AIProvider {
    readonly name = 'claude';
    readonly displayName = 'Claude (Anthropic)';
    private apiKey: string;

    constructor(apiKey: string) {
        this.apiKey = apiKey;
    }

    async validateApiKey(): Promise<boolean> {
        try {
            await this.callAPI('estimateGoalEffort', { goalText: 'test' });
            return true;
        } catch (error) {
            console.warn('Claude API key validation failed:', error);
            return false;
        }
    }

    private async callAPI(action: string, payload: any): Promise<string> {
        const response = await fetch('/api/ai/claude', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ apiKey: this.apiKey, action, payload }),
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'API call failed');
        }

        const data = await response.json();
        // The API returns 'result' which is a JSON string generated by enforcement.ts
        return data.result;
    }

    async decomposeGoal(goalText: string, targetDate?: string, userFeedback?: string, isLifelong?: boolean, traceId?: string): Promise<GoalPlan> {
        try {
            // New prompt architecture doesn't use userFeedback/isLifelong/traceId in the same way yet, 
            // but we keep signature for compatibility.
            const resultString = await this.callAPI('decomposeGoal', { goalText, targetDate });
            const parsed = JSON.parse(resultString);

            return {
                rationale: parsed.rationale, // Might be undefined in new schema, that's optional in interface
                tasks: (parsed.tasks || []).map((t: any) => ({
                    title: t.title || t.content,
                    estimatedTotalMinutes: t.estimatedTotalMinutes || t.estimatedMinutes || 120,
                }))
            };
        } catch (error) {
            console.error('Claude decomposeGoal error:', error);
            throw error;
        }
    }

    async decomposeTask(taskTitle: string, taskTotalMinutes: number, otherTasks?: string[], priorCapabilities?: string[]): Promise<TaskPlan> {
        try {
            const resultString = await this.callAPI('decomposeTask', { taskTitle, taskTotalMinutes, otherTasks, priorCapabilities });
            const parsed = JSON.parse(resultString);

            return {
                workUnits: (parsed.workUnits || []).map((u: any) => ({
                    title: u.title,
                    kind: u.kind || 'practice',
                    estimatedTotalMinutes: u.estimatedTotalMinutes || 60
                }))
            };
        } catch (error) {
            console.error('Claude decomposeTask error:', error);
            throw error;
        }
    }

    async estimateGoalEffort(goalText: string): Promise<EffortEstimate> {
        try {
            const resultString = await this.callAPI('estimateGoalEffort', { goalText });
            // This one might still be raw markdown if the route just returned text? 
            // Check route: 'return NextResponse.json({ result: text });' 
            // text comes from model directly. 
            // We should parse it lightly or expect JSON if prompt requested it.
            // Prompt says "Respond with JSON only". So we try to parse.

            const jsonText = resultString.includes('```json')
                ? resultString.split('```json')[1].split('```')[0].trim()
                : resultString;

            const parsed = JSON.parse(jsonText);

            return {
                estimatedTotalMinutes: parsed.estimatedTotalMinutes || 600,
                confidence: parsed.confidence || 'low',
                rationale: parsed.rationale,
            };
        } catch (error) {
            console.error('Claude estimateGoalEffort error:', error);
            return { estimatedTotalMinutes: 600, confidence: 'low' };
        }
    }
}
