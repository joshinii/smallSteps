// SmallSteps Claude Adapter
// Implements AIProvider interface using server-side API route

import type { AIProvider, GoalPlan, TaskPlan, EffortEstimate, ClarificationQuestion, ClarificationResult } from './ai-provider';

export class ClaudeAdapter implements AIProvider {
    readonly name = 'claude';
    readonly displayName = 'Claude (Anthropic)';
    private apiKey: string;

    constructor(apiKey: string) {
        this.apiKey = apiKey;
    }

    async validateApiKey(): Promise<boolean> {
        try {
            await this.callAPI('estimateGoalEffort', { goalText: 'test' });
            return true;
        } catch (error) {
            console.warn('Claude API key validation failed:', error);
            return false;
        }
    }

    private async callAPI(action: string, payload: any): Promise<string> {
        const response = await fetch('/api/ai/claude', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ apiKey: this.apiKey, action, payload }),
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'API call failed');
        }

        const data = await response.json();
        // The API returns 'result' which is a JSON string generated by enforcement.ts
        return data.result;
    }

    async clarifyGoal(goalText: string, traceId?: string): Promise<ClarificationQuestion[]> {
        try {
            const resultString = await this.callAPI('clarifyGoal', { goalText, traceId });
            const parsed = JSON.parse(resultString);

            // Validate and return questions
            const questions = parsed.questions || [];
            return questions.slice(0, 3).map((q: any) => ({
                id: q.id || `q_${Math.random().toString(36).slice(2)}`,
                questionText: q.questionText,
                planningDimension: q.planningDimension || 'scope',
                options: (q.options || []).map((o: any) => ({
                    value: o.value,
                    label: o.label,
                    planningHint: o.planningHint
                }))
            }));
        } catch (error) {
            console.error('Claude clarifyGoal error:', error);
            throw error;
        }
    }

    async decomposeGoal(goalText: string, targetDate?: string, userFeedback?: string, isLifelong?: boolean, traceId?: string, clarificationContext?: ClarificationResult): Promise<GoalPlan> {
        try {
            // Pass clarification context to improve planning
            const clarificationPayload = clarificationContext?.planningContext || undefined;
            const resultString = await this.callAPI('decomposeGoal', { goalText, targetDate, clarificationContext: clarificationPayload });
            const parsed = JSON.parse(resultString);

            return {
                rationale: parsed.rationale,
                tasks: (parsed.tasks || []).map((t: any) => ({
                    title: t.title || t.content,
                    estimatedTotalMinutes: t.estimatedTotalMinutes || t.estimatedMinutes || 120,
                    whyThisMatters: t.whyThisMatters // Pass through quality field
                }))
            };
        } catch (error) {
            console.error('Claude decomposeGoal error:', error);
            throw error;
        }
    }

    async decomposeTask(taskTitle: string, taskTotalMinutes: number, otherTasks?: string[], priorCapabilities?: string[]): Promise<TaskPlan> {
        try {
            const resultString = await this.callAPI('decomposeTask', { taskTitle, taskTotalMinutes, otherTasks, priorCapabilities });
            const parsed = JSON.parse(resultString);

            return {
                workUnits: (parsed.workUnits || []).map((u: any) => ({
                    title: u.title,
                    kind: u.kind || 'practice',
                    estimatedTotalMinutes: u.estimatedTotalMinutes || 60,
                    capabilityId: u.capabilityId,
                    firstAction: u.firstAction,   // Pass through quality field
                    successSignal: u.successSignal // Pass through quality field
                }))
            };
        } catch (error) {
            console.error('Claude decomposeTask error:', error);
            throw error;
        }
    }

    async estimateGoalEffort(goalText: string): Promise<EffortEstimate> {
        try {
            const resultString = await this.callAPI('estimateGoalEffort', { goalText });
            // This one might still be raw markdown if the route just returned text? 
            // Check route: 'return NextResponse.json({ result: text });' 
            // text comes from model directly. 
            // We should parse it lightly or expect JSON if prompt requested it.
            // Prompt says "Respond with JSON only". So we try to parse.

            const jsonText = resultString.includes('```json')
                ? resultString.split('```json')[1].split('```')[0].trim()
                : resultString;

            const parsed = JSON.parse(jsonText);

            return {
                estimatedTotalMinutes: parsed.estimatedTotalMinutes || 600,
                confidence: parsed.confidence || 'low',
                rationale: parsed.rationale,
            };
        } catch (error) {
            console.error('Claude estimateGoalEffort error:', error);
            return { estimatedTotalMinutes: 600, confidence: 'low' };
        }
    }
}
